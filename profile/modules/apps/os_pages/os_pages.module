<?php

/**
 * @file
 * Pages app.
 */

use Drupal\Core\Cache\RefinableCacheableDependencyInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\node\Entity\Node;
use Drupal\block_visibility_groups\Entity\BlockVisibilityGroup;
use Drupal\Core\Form\FormStateInterface;
use Drupal\node\NodeInterface;

/**
 * Implements hook_entity_insert().
 *
 * @throws \Drupal\Core\Entity\EntityStorageException
 */
function os_pages_entity_insert(EntityInterface $entity) {
  /** @var \Drupal\os_pages\VisibilityHelper $visibility_helper */
  $visibility_helper = \Drupal::service('os_pages.visibility_helper');

  if ($entity->getEntityTypeId() != 'node' || $entity->bundle() != 'page') {
    return;
  }

  /** @var \Drupal\Core\Path\AliasManagerInterface $alias_manager */
  $alias_manager = \Drupal::service('path.alias_manager');

  $layout_context_storage = \Drupal::entityTypeManager()->getStorage('layout_context');
  $layout_context_storage->create([
    'id' => "os_pages_page_{$entity->id()}",
    'label' => t('Page Layout For @label', ['@label' => $entity->label()]),
    'activationRules' => $alias_manager->getAliasByPath("/node/{$entity->id()}"),
    'weight' => 100,
  ])->save();

  /** @var \Drupal\os_pages\VisibilityStorageInterface $visibility_storage */
  $visibility_storage = \Drupal::service('os_pages.visibility_storage');

  // Create page visibility group.
  $visibility_storage->create([
    'id' => "os_pages_page_{$entity->id()}",
    'label' => t('OS Pages: Page @name', [
      '@name' => $entity->label(),
    ]),
    'status' => TRUE,
    'allow_other_conditions' => TRUE,
    'logic' => 'and',
  ], [
    [
      'id' => 'node_type',
      'bundles' => [
        $entity->bundle() => $entity->bundle(),
      ],
      'negate' => FALSE,
      'context_mapping' => [
        'node' => '@node.node_route_context:node',
      ],
    ],
    [
      'id' => 'request_path',
      'pages' => "/node/{$entity->id()}",
      'negate' => FALSE,
      'context_mapping' => [],
    ],
  ]);

  if (!$visibility_helper->isBookPage($entity)) {
    return;
  }

  /** @var \Drupal\node\NodeInterface $book */
  $book = Node::load($entity->book['bid']);

  $section_id = "os_pages_section_{$book->id()}";
  /** @var \Drupal\os_widgets\LayoutContextInterface $section_layout */
  $section_layout = $layout_context_storage->load($section_id);
  // No book section yet.
  if (!$section_layout) {
    if ($visibility_helper->isBookFirstPage($entity)) {
      $section_layout = $layout_context_storage->create([
        'id' => $section_id,
        'label' => t('Section Layout For @label', ['@label' => $book->label()]),
        'activationRules' => implode("\n", [
          $alias_manager->getAliasByPath("/node/{$book->id()}"),
          $alias_manager->getAliasByPath("/node/{$entity->id()}"),
        ]),
        'weight' => 50,
        'data' => [
          'book_navigation' => [
            'id' => 'book_navigation',
            'region' => 'sidebar_first',
            'weight' => 0,
          ],
        ],
      ]);
      $section_layout->save();
    }
  }
  else {
    $paths = $section_layout->getActivationRules();
    $paths = explode("\n", $paths);
    $paths[] = $alias_manager->getAliasByPath("/node/{$entity->id()}");
    $section_layout->setActivationRules(implode("\n", $paths));
    $section_layout->save();
  }

  /** @var \Drupal\block_visibility_groups\Entity\BlockVisibilityGroup|null $section_visibility_group */
  $section_visibility_group = BlockVisibilityGroup::load($section_id);

  // Create/update section visibility group.
  if (!$section_visibility_group) {
    if ($visibility_helper->isBookFirstPage($entity)) {

      $visibility_storage->create([
        'id' => "os_pages_section_{$book->id()}",
        'label' => t('OS Pages: Section @book_name', [
          '@book_name' => $book->label(),
        ]),
        'status' => TRUE,
        'allow_other_conditions' => TRUE,
        'logic' => 'and',
      ], [
        [
          'id' => 'node_type',
          'bundles' => [
            $entity->bundle() => $entity->bundle(),
          ],
          'negate' => FALSE,
          'context_mapping' => [
            'node' => '@node.node_route_context:node',
          ],
        ],
        [
          'id' => 'request_path',
          'pages' => "/node/{$book->id()}\n/node/{$entity->id()}",
          'negate' => FALSE,
          'context_mapping' => [],
        ],
      ]);
    }
  }
  else {
    // Update the path condition for section visibility group.
    // Making sure that it appears for the newly created page as well.
    /** @var array $conditions */
    $conditions = $section_visibility_group->getConditions()->getConfiguration();

    foreach ($conditions as $condition) {
      if ($condition['id'] === 'request_path') {
        /** @var string $condition_id */
        $condition_id = $condition['uuid'];
        /** @var string $pages */
        $pages = $condition['pages'];
      }
    }

    if (!isset($condition_id) && !isset($pages)) {
      return;
    }

    $section_visibility_group->removeCondition($condition_id);

    $section_visibility_group->addCondition([
      'id' => 'request_path',
      'pages' => "$pages\n/node/{$entity->id()}",
      'negate' => 0,
      'context_mapping' => [],
    ]);

    $section_visibility_group->save();
  }
}

/**
 * Implements hook_ENTITY_TYPE_prepare_form() for pre-setting the data required for creating sub-pages.
 *
 * This is an exact copy of `book_node_prepare_form`. It has wrapped everything
 * in an access check, which makes it impossible to create sub-pages by vsite
 * members.
 *
 * @see \book_node_prepare_form
 */
function os_pages_node_prepare_form(NodeInterface $node, $operation, FormStateInterface $form_state) {
  /** @var \Drupal\vsite\Plugin\VsiteContextManagerInterface $vsite_context_manager */
  $vsite_context_manager = \Drupal::service('vsite.context_manager');
  /** @var \Drupal\group\Entity\GroupInterface|null $active_vsite */
  $active_vsite = $vsite_context_manager->getActiveVsite();

  // Let the book module handle everything, if node is not meant to be created
  // for a vsite.
  if ($active_vsite && book_type_is_allowed($node->getType())) {
    /** @var \Drupal\book\BookManagerInterface $book_manager */
    $book_manager = \Drupal::service('book.manager');
    if (empty($node->book)) {
      $node->book = [];

      $query = \Drupal::request()->query;
      if ($node->isNew() && $query->get('parent') !== NULL && is_numeric($query->get('parent'))) {
        // Handle "Add child page" links:
        $parent = $book_manager->loadBookLink($query->get('parent'), TRUE);

        if ($parent && $parent['access']) {
          $node->book['bid'] = $parent['bid'];
          $node->book['pid'] = $parent['nid'];
        }
      }
      // Set defaults.
      $node_ref = !$node->isNew() ? $node->id() : 'new';
      $node->book += $book_manager->getLinkDefaults($node_ref);
    }
    elseif (isset($node->book['bid']) && !isset($node->book['original_bid'])) {
      $node->book['original_bid'] = $node->book['bid'];
    }

    // Find the depth limit for the parent select.
    if (isset($node->book['bid']) && !isset($node->book['parent_depth_limit'])) {
      $node->book['parent_depth_limit'] = $book_manager->getParentDepthLimit($node->book);
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for making sure the vsite users are able to create and manage sub-pages.
 *
 * Much of the code is similar to `book_form_node_form_alter`. It has wrapped
 * everything inside an access check, that makes it impossible to create a
 * sub-page by vsite members.
 *
 * @see \book_form_node_form_alter
 */
function os_pages_form_node_page_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  /** @var \Drupal\vsite\Plugin\VsiteContextManagerInterface $vsite_context_manager */
  $vsite_context_manager = \Drupal::service('vsite.context_manager');
  /** @var \Drupal\group\Entity\GroupInterface|null $active_vsite */
  $active_vsite = $vsite_context_manager->getActiveVsite();

  // Let the book module handle everything, if node is not meant to be created
  // for a vsite.
  if (!$active_vsite) {
    return;
  }

  /** @var \Drupal\Core\Session\AccountInterface $current_user */
  $current_user = \Drupal::currentUser();
  /** @var \Drupal\book\BookManagerInterface $book_manager */
  $book_manager = \Drupal::service('book.manager');
  /** @var \Drupal\node\NodeInterface $node */
  $node = $form_state->getFormObject()->getEntity();
  $is_already_in_page_hierarchy = !($node->isNew() && !empty($node->book['pid']));

  $access = ($active_vsite->hasPermission('add content to books', $current_user) && book_type_is_allowed($node->getType()));

  $form = $book_manager->addFormElements($form, $form_state, $node, $current_user, $is_already_in_page_hierarchy);
  // Override the accesses given inside book module.
  $form['book']['#access'] = $access;
  $form['book']['bid']['#access'] = $access;

  $nid = !$node->isNew() ? $node->id() : 'new';
  $options = $form['book']['bid']['#options'];
  if (($nid === 'new' || ($nid != $node->book['original_bid'])) &&
    $active_vsite->hasPermission('create new books', $current_user)) {
    // The node can become a new book, if it is not one already.
    $options = [$nid => t('- Create a new book -')] + $options;
  }
  $form['book']['bid']['#options'] = $options;

  // The "js-hide" class hides submit button when Javascript is enabled.
  $form['book']['pick-book'] = [
    '#type' => 'submit',
    '#value' => t('Change book (update list of parents)'),
    '#submit' => ['book_pick_book_nojs_submit'],
    '#weight' => 20,
    '#attributes' => [
      'class' => [
        'js-hide',
      ],
    ],
  ];
  $form['#entity_builders'][] = 'book_node_builder';
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function os_pages_menu_local_tasks_alter(&$data, $route_name, RefinableCacheableDependencyInterface &$cacheability) {
  $node = \Drupal::routeMatch()->getParameter('node');
  if ($node instanceof NodeInterface && $node->bundle() !== 'page' && isset($data['tabs'][0])) {
    foreach ($data['tabs'][0] as $task => $tab) {
      if (strpos($task, 'book_outline') !== FALSE) {
        unset($data['tabs'][0][$task]);
      }
    }
  }
}

/**
 * Implements hook_module_implements_alter().
 *
 * Force os_pages to be behind pathauto so we can read aliases.
 */
function os_pages_module_implements_alter(&$implementations, $hook) {
  if ($hook == 'entity_insert') {
    $group = $implementations['os_pages'];
    unset($implementations['os_pages']);
    $implementations['os_pages'] = $group;
  }
}

/**
 * Implements hook_contextual_links_view_alter().
 */
function os_pages_contextual_links_view_alter(&$element, $items) {
  if (isset($element['#contextual_links']['node'])) {
    $entity = entity_load('node', $element['#contextual_links']['node']['route_parameters']['node']);

    // Checking content type page.
    if ($entity->get('type')->getString() == 'page') {
      $element['#links']['outlone'] = [
        'title' => t('Outline'),
        'url' => Url::fromRoute('entity.node.book_outline_form', [
          'node' => $entity->id(),
        ]),
      ];

      $element['#links']['add_subpage'] = [
        'title' => t('Add Subpage'),
        'url' => Url::fromRoute('node.add', [
          'node_type' => 'page',
          'parent' => $entity->id(),
        ]),
      ];
    }
  }
}
